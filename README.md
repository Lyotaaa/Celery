# Установка и запуск

## Подготовка. Запустить файл docker compose командой. 
```
docker compose up -d
```
## Запустите файл client.py
### Вариант №1 через терминал
```
docker compose exec app bash
```
```
python client.py
```
Результат работы кода
```
Start post method
87fde86e-974a-4b37-a892-df572717c3e8

Start get method
{'status': 'PENDING'}
{'status': 'PENDING'}
{'status': 'PENDING'}
{'status': 'PENDING'}
{'status': 'PENDING'}
{'status': 'PENDING'}
{'status': 'PENDING'}
{'status': 'PENDING'}
{'link': 'http://127.0.0.1:5000/upscaling/lama_300px_upscaled.png', 'status': 'SUCCESS'}

Second get method
Done!
Время загрузки изображения: 0:00:20.187632
```
### Вариант №2 через приложение докер
Необходимо зайти в Docker. Открыть контейнер app. Перейти во вкладку терминал. Введите команду.
```
python client.py
```
Результат работы аналогичный.

#### После завершения работы кода, в папке result появятся исходный файл и обработанный..

# Домашнее задание к лекции «Celery»

Специалист по машинному обучению создал модель для 
[апскейлинга](https://ru.wiktionary.org/wiki/%D0%B0%D0%BF%D1%81%D0%BA%D0%B5%D0%B9%D0%BB%D0%B8%D0%BD%D0%B3) 
изображений и функцию, которую позволяет ее использовать.  
Файлы проекта находится [здесь](app.py).  
`EDSR_2.pb` - модель.  
В модуле `app.py` находится функция `upscale`, которая имплементирует модель.  
В файле `requirements.txt` перечислены зависимости

Перед Вами стоит задача написать сервис для апскейлинга изображений на базе Flask, Celery и ИИ модели.
Должно быть реализовано 3 роута
- POST `/upscale`. Принимает файл с изображением и возвращает id задачи
- GET `/tasks/<task_id>` возвращает статус задачи и ссылку на обработанный файл, если задача выполнена
- GET `/processed/{file}` возвращает обработанный файл

Дополнительные задачи:
- перепишите функцию `upscale` так, чтобы файл `EDSR_x2.pb` считывался только один раз, а не при каждом вызове функции
- попробуйте написать сервис и функцию `upscale` таким образом, чтобы не сохранять файлы изображений на диск
- докеризируйте приложение
- напишите тесты

Результатом работы является рабочее API.
